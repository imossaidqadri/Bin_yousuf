---
// src/components/islands/ProjectAnimationIsland.astro
interface Props {
  projects: Array<{
    id: string;
    name: string;
    location: string;
  }>;
}

const { projects } = Astro.props;
---

<!-- This island will manage the project animations -->
<div id="project-animation-island" class="relative">
  <slot />
</div>

<script>
  // Dynamically load GSAP when the script runs
  (async () => {
    const gsapModule = await import('gsap');
    const ScrollToPluginModule = await import('gsap/ScrollToPlugin');
    
    const gsap = gsapModule.default;
    const ScrollToPlugin = ScrollToPluginModule.default;
    
    gsap.registerPlugin(ScrollToPlugin);

    // Get DOM elements
    const projectsSidebar = document.getElementById('projectsSidebar');
    const animatedProjectImage = document.getElementById('animatedProjectImage');
    const mainAnimatedImage = document.getElementById('mainAnimatedImage');
    const firstProjectInGrid = document.querySelector('#project-1');
    
    let ticking = false;
    let mainTimeline = null;
    
    // Initialize GSAP animations
    function initializeGSAPAnimations() {
      if (!animatedProjectImage) return;

      // Create main timeline
      mainTimeline = gsap.timeline({ paused: true });

      // Set initial state
      gsap.set(animatedProjectImage, {
        top: '100vh',
        left: '0',
        width: '100vw',
        height: '100vh',
        opacity: 0,
        borderRadius: '0px',
        zIndex: 999,
      });

      // Create animation sequence
      mainTimeline
        // Phase 1: Scale up from bottom and fade in (0 -> 0.4)
        .to(animatedProjectImage, {
          top: '0vh',
          opacity: 1,
          duration: 0.4,
          ease: 'power2.out',
        })
        // Phase 2: Shrink and move to grid position (0.4 -> 0.95)
        .to(animatedProjectImage, {
          top: '12vh',
          left: '38vw',
          width: '60vw',
          height: '60vh',
          borderRadius: '12px',
          duration: 0.55,
          ease: 'power2.inOut',
        })
        // Phase 3: Final positioning (0.95 -> 1.0)
        .to(animatedProjectImage, {
          duration: 0.05,
          ease: 'none',
        });
    }

    function updateScrollAnimation() {
      const scrollY = window.scrollY;
      const windowHeight = window.innerHeight;

      // Calculate positions
      const heroHeight = windowHeight * 1.1;
      const projectsSectionPadding = windowHeight * 0.12;
      const firstProjectPosition = heroHeight + projectsSectionPadding;
      const scrollStart = firstProjectPosition - windowHeight * 0.8;
      const scrollRange = windowHeight * 1.5;

      // Get footer element and its position
      const footer = document.querySelector('footer');
      const footerTop = footer
        ? footer.getBoundingClientRect().top + scrollY
        : Infinity;

      // Calculate if we're near the footer (with some buffer)
      const footerBuffer = windowHeight * 0.3; // 30% of viewport height as buffer
      const isNearFooter = scrollY + windowHeight > footerTop - footerBuffer;

      // Update sidebar visibility - hide if near footer
      const sidebarThreshold = windowHeight * 0.2;
      const shouldShowSidebar = scrollY > sidebarThreshold && !isNearFooter;
      updateSidebarVisibility(shouldShowSidebar);

      // Calculate progress
      const progress = Math.min(
        Math.max((scrollY - scrollStart) / scrollRange, 0),
        1
      );

      // Update timeline progress
      if (mainTimeline) {
        mainTimeline.progress(progress);
      }

      // Handle crossfade between animated and grid images
      handleImageCrossfade(progress);
    }

    function updateSidebarVisibility(visible) {
      if (projectsSidebar) {
        if (visible) {
          gsap.killTweensOf(projectsSidebar);
          gsap.fromTo(
            projectsSidebar,
            { opacity: 0, x: -100 },
            { opacity: 1, x: 0, duration: 0.5, ease: 'power2.out' }
          );
        } else {
          gsap.killTweensOf(projectsSidebar);
          gsap.to(projectsSidebar, {
            opacity: 0,
            x: -100,
            duration: 0.3,
            ease: 'power2.in',
          });
        }
      }
    }

    function handleImageCrossfade(progress) {
      if (!animatedProjectImage || !firstProjectInGrid) return;

      if (progress < 0.95) {
        gsap.set(firstProjectInGrid, { opacity: 0 });
      } else if (progress >= 0.95 && progress < 1) {
        const fadeProgress = (progress - 0.95) / 0.05;
        gsap.set(animatedProjectImage, { opacity: 1 - fadeProgress });
        gsap.set(firstProjectInGrid, { opacity: fadeProgress });
      } else {
        gsap.set(firstProjectInGrid, { opacity: 1 });
        gsap.set(animatedProjectImage, {
          opacity: 0,
          pointerEvents: 'none',
        });
      }
    }

    function scrollToProject(projectIndex) {
      const targetElement = document.getElementById(
        `project-${projectIndex + 1}`
      );
      if (targetElement) {
        gsap.to(window, {
          scrollTo: { y: targetElement, offsetY: 80 },
          duration: 1,
          ease: 'power2.out',
        });
      }
    }

    function highlightProject(projectElement) {
      gsap
        .timeline()
        .to(projectElement, {
          y: -15,
          boxShadow: '0 40px 100px rgba(0, 0, 0, 0.25)',
          duration: 0.6,
          ease: 'power2.out',
        })
        .to(
          projectElement.querySelector('.project-image'),
          {
            scale: 1.02,
            duration: 0.6,
            ease: 'power2.out',
          },
          0
        )
        .to(projectElement, {
          y: 0,
          boxShadow: '0 20px 60px rgba(0, 0, 0, 0.15)',
          duration: 0.6,
          ease: 'power2.out',
          delay: 1.4,
        })
        .to(
          projectElement.querySelector('.project-image'),
          {
            scale: 1,
            duration: 0.6,
            ease: 'power2.out',
          },
          '-=0.6'
        );
    }

    // Initialize GSAP animations
    initializeGSAPAnimations();
    
    // Setup scroll handler
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          updateScrollAnimation();
          ticking = false;
        });
        ticking = true;
      }
    };

    // Setup resize handler
    const handleResize = () => {
      // Handle resize if needed
    };

    // Add event listeners
    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('resize', handleResize);

    // Initial update
    updateScrollAnimation();

    // Cleanup when the page changes
    document.addEventListener('astro:page-load', () => {
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleResize);
      if (mainTimeline) {
        mainTimeline.kill();
      }
    });
  })();
</script>